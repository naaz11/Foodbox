{"ast":null,"code":"import { environment } from 'src/environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\n/* We mark our Product service as avaiable for dependency injection by decorating it with\r\n   the @Injectable() annotation. */\n\nexport class CuisineService {\n  //Constructor\n  //whenever we generate a ProductService object, it will have the ability to perform HTTP requests due to dependency injection\n  //Note: HttpClient will not send the raw data. It will send an Observable that you will have to subscribe to.\n  constructor(http) {\n    this.http = http; //Properties\n\n    this.restUrl = environment.restUrl; //obtained from the development env settings\n  } //HTTP Methods - should mirror the CuisineController on the backend\n\n  /* Notes: For Angular to connect to backend servers, we need Observables (from Reactive Extension library)\r\n   * An Observable represents an asynchronous data stream where data arrives asynchronously.\r\n   * Observables provide support for passing messages between part of your application\r\n   * The observer pattern is a software design pattern in which an object (subject),\r\n   * maintains a list of its dependents (observers/subscribers/watchers), and notifies them automatically of state changes.\r\n   * Observables are declarative — that is, you define a function for publishing values, but\r\n   * it is not executed until a consumer subscribes to it.\r\n   * The subscribed consumer then receives notifications until the function completes, or until they unsubscribe.\r\n   * Source: https://angular.io/guide/observables\r\n   */\n\n  /* *******************************************\r\n   * Method Name: getAllCuisines()\r\n   * Access Type: public\r\n   * Input Parameters: none\r\n   * Return Type: Observable Cuisine[] array\r\n   * Purpose: Calls the backend endpoint (HTTP GET)\r\n   * ******************************************* */\n\n\n  getAllCuisines() {\n    return this.http.get(`${this.restUrl}/cuisines/all`);\n  }\n  /* *******************************************\r\n   * Method Name: addCuisine()\r\n   * Access Type: public\r\n   * Input Parameters: Cuisine Object\r\n   * Return Type: Observable of any Cuisine object\r\n   * Purpose: Calls the backend /products/add endpoint (HTTP POST)\r\n   * ******************************************* */\n\n\n  addCuisine(cuisine) {\n    return this.http.post(`${this.restUrl}/cuisines/add`, cuisine);\n  }\n  /* *******************************************\r\n   * Method Name: updateCuisine()\r\n   * Access Type: public\r\n   * Input Parameters: Single Cuisine object\r\n   * Return Type: Observable of Cuisine\r\n   * Purpose: Calls the backend /products/product/update/id endpoint (HTTP PUT)\r\n   * ******************************************* */\n\n\n  updateCuisine(cuisine, id) {\n    return this.http.put(`${this.restUrl}/cuisines/cuisine/update/${id}`, cuisine);\n  }\n\n} //end class\n\nCuisineService.ɵfac = function CuisineService_Factory(t) {\n  return new (t || CuisineService)(i0.ɵɵinject(i1.HttpClient));\n};\n\nCuisineService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: CuisineService,\n  factory: CuisineService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"AAIA,SAASA,WAAT,QAA4B,8BAA5B;;;AAEA;;;AAKA,OAAM,MAAOC,cAAP,CAAqB;EAIzB;EACA;EACA;EACAC,YAAoBC,IAApB,EAAmC;IAAf,iBAAe,CANnC;;IACQ,eAAiBH,WAAW,CAACI,OAA7B,CAK2B,CALW;EAKN,CAPf,CASzB;;EAEA;;;;;;;;;;;EAWA;;;;;;;;;EAOAC,cAAc;IACZ,OAAO,KAAKF,IAAL,CAAUG,GAAV,CAAyB,GAAG,KAAKF,OAAO,eAAxC,CAAP;EACD;EAED;;;;;;;;;EAOOG,UAAU,CAACC,OAAD,EAAgB;IAC/B,OAAO,KAAKL,IAAL,CAAUM,IAAV,CAAwB,GAAG,KAAKL,OAAO,eAAvC,EAAwDI,OAAxD,CAAP;EACD;EAED;;;;;;;;;EAOOE,aAAa,CAACF,OAAD,EAAmBG,EAAnB,EAA4B;IAChD,OAAO,KAAKR,IAAL,CAAUS,GAAV,CAAuB,GAAG,KAAKR,OAAO,4BAA4BO,EAAE,EAApE,EAAwEH,OAAxE,CAAP;EACD;;AArD0B,C,CAuD1B;;;mBAvDYP,gBAAcY;AAAA;;;SAAdZ;EAAca,SAAdb,cAAc;EAAAc,YAFb","names":["environment","CuisineService","constructor","http","restUrl","getAllCuisines","get","addCuisine","cuisine","post","updateCuisine","id","put","i0","factory","providedIn"],"sourceRoot":"","sources":["C:\\Users\\Ameer\\Documents\\naaz-codes\\simplilearn_7\\downloaded_codes\\Phase 5 Capstone - Food Box\\frontend\\src\\app\\services\\cuisine\\cuisine.service.ts"],"sourcesContent":["import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { Cuisine } from 'src/app/models/Cuisine';\nimport { environment } from 'src/environments/environment';\n\n/* We mark our Product service as avaiable for dependency injection by decorating it with\n   the @Injectable() annotation. */\n@Injectable({\n  providedIn: 'root'\n})\nexport class CuisineService {\n  //Properties\n  private restUrl:string = environment.restUrl; //obtained from the development env settings\n\n  //Constructor\n  //whenever we generate a ProductService object, it will have the ability to perform HTTP requests due to dependency injection\n  //Note: HttpClient will not send the raw data. It will send an Observable that you will have to subscribe to.\n  constructor(private http:HttpClient) { }\n\n  //HTTP Methods - should mirror the CuisineController on the backend\n\n  /* Notes: For Angular to connect to backend servers, we need Observables (from Reactive Extension library)\n   * An Observable represents an asynchronous data stream where data arrives asynchronously.\n   * Observables provide support for passing messages between part of your application\n   * The observer pattern is a software design pattern in which an object (subject),\n   * maintains a list of its dependents (observers/subscribers/watchers), and notifies them automatically of state changes.\n   * Observables are declarative — that is, you define a function for publishing values, but\n   * it is not executed until a consumer subscribes to it.\n   * The subscribed consumer then receives notifications until the function completes, or until they unsubscribe.\n   * Source: https://angular.io/guide/observables\n   */\n\n  /* *******************************************\n   * Method Name: getAllCuisines()\n   * Access Type: public\n   * Input Parameters: none\n   * Return Type: Observable Cuisine[] array\n   * Purpose: Calls the backend endpoint (HTTP GET)\n   * ******************************************* */\n  getAllCuisines(): Observable<Cuisine[]> {\n    return this.http.get<Cuisine[]>(`${this.restUrl}/cuisines/all`);\n  }\n\n  /* *******************************************\n   * Method Name: addCuisine()\n   * Access Type: public\n   * Input Parameters: Cuisine Object\n   * Return Type: Observable of any Cuisine object\n   * Purpose: Calls the backend /products/add endpoint (HTTP POST)\n   * ******************************************* */\n  public addCuisine(cuisine:Cuisine):Observable<Cuisine>{\n    return this.http.post<Cuisine>(`${this.restUrl}/cuisines/add`, cuisine);\n  }\n\n  /* *******************************************\n   * Method Name: updateCuisine()\n   * Access Type: public\n   * Input Parameters: Single Cuisine object\n   * Return Type: Observable of Cuisine\n   * Purpose: Calls the backend /products/product/update/id endpoint (HTTP PUT)\n   * ******************************************* */\n  public updateCuisine(cuisine: Cuisine, id:number): Observable<Cuisine> {\n  return this.http.put<Cuisine>(`${this.restUrl}/cuisines/cuisine/update/${id}`, cuisine);\n}\n\n}//end class\n"]},"metadata":{},"sourceType":"module"}